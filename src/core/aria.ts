import * as ng from 'angular';
import { NgProvider, method } from './decorator';
import { IMDUtilServices } from './util';

/**
 * @ngdoc service
 * @name $mdAriaProvider
 * @module material.core.aria
 *
 * @description
 *
 * Modify options of the `$mdAria` service, which will be used by most of the AngularJS Material
 * components.
 *
 * You are able to disable `$mdAria` warnings, by using the following markup.
 *
 * <hljs lang="js">
 *   app.config(function($mdAriaProvider) {
 *     // Globally disables all ARIA warnings.
 *     $mdAriaProvider.disableWarnings();
 *   });
 * </hljs>
 *
 */
// @NgService('$mdAria')
export  class MdAriaProvider {
  protected config = {
    /** Whether we should show ARIA warnings in the console if labels are missing on the element */
    showWarnings: true
  };
  constructor() {
    'ngInject';

  }
  /**
   * @ngdoc method
   * @name $mdAriaProvider#disableWarnings
   * @description Disables all ARIA warnings generated by AngularJS Material.
   */
  @method
  public disableWarnings() {
    this.config.showWarnings = false;
  }
}
@NgProvider(MdAriaProvider)
export class MdAriaServices extends MdAriaProvider {
  private showWarnings_: boolean = false;
  constructor(private $$rAF: any, private $log: ng.ILogService, private $window: ng.IWindowService, private $interpolate: ng.IInterpolateService, private $mdUtil: IMDUtilServices) {
    'ngInject';
    super();
  }
  private childHasAttribute(node: HTMLElement, attrName: string) {
    let self = this;
    let hasChildren = node.hasChildNodes(),
        hasAttr = false;

    let isHidden = (el: any) => {
      let style = el.currentStyle ? el.currentStyle : self.$window.getComputedStyle(el);
      return (style.display === 'none');
    };

    if (hasChildren) {
      let children = node.childNodes;
      children.forEach((child: HTMLElement) => {
        if (child.nodeType === 1 && child.hasAttribute(attrName)) {
          if (!isHidden(child)) {
            hasAttr = true;
          }
        }
      });
    }
    return hasAttr;
  }
  @method
  public showWarnings(val: boolean = false) {
    this.showWarnings_ = val;
  }
  /**
   * Check if expected attribute has been specified on the target element or child
   * @param element
   * @param attrName
   * @param {optional} defaultValue What to set the attr to if no value is found
   */
  @method
  public expect(element: JQLite, attrName: string, defaultValue?: any) {

    let node: HTMLElement = this.$mdUtil.getNativeElement(element);

    // if node exists and neither it nor its children have the attribute
    if (node &&
       ((!node.hasAttribute(attrName) ||
        node.getAttribute(attrName).length === 0) &&
        !this.childHasAttribute(node, attrName))) {

      defaultValue = ng.isString(defaultValue) ? defaultValue.trim() : '';
      if (defaultValue.length) {
        element.attr(attrName, defaultValue);
      } else if (this.showWarnings_) {
        this.$log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node);
      }
    }
  }
  @method
  public expectAsync(element: JQLite, attrName: string, defaultValueGetter: Function) {
    // Problem: when retrieving the element's contents synchronously to find the label,
    // the text may not be defined yet in the case of a binding.
    // There is a higher chance that a binding will be defined if we wait one frame.
    let self = this;
    this.$$rAF(function() {
        self.expect(element, attrName, defaultValueGetter());
    });
  }
  private getText(element: JQLite) {
    let el = this.$mdUtil.getNativeElement(element);
    let walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
    let text = '';

    let node: any;
    function isAriaHiddenNode(node: any) {
      while (node.parentNode && (node = node.parentNode) !== element) {
        if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') {
          return true;
        }
      }
    }
    while (node = walker.nextNode()) {
      if (!isAriaHiddenNode(node)) {
        text += node.textContent;
      }
    }

    return text.trim() || '';
  }
  @method
  public expectWithText(element: JQLite, attrName: string) {
    let content = this.getText(element) || '';
    let hasBinding = content.indexOf(this.$interpolate.startSymbol()) > -1;
    if (hasBinding) {
      this.expectAsync(element, attrName, function() {
        return this.getText(element);
      });
    } else {
      this.expect(element, attrName, content);
    }
  }
  @method
  public expectWithoutText(element: JQLite, attrName: string) {
    let content = this.getText(element);
    let hasBinding = content.indexOf(this.$interpolate.startSymbol()) > -1;
    if (!hasBinding && !content) {
      this.expect(element, attrName, content);
    }
  }
  /**
   * Check if expected element has aria label attribute
   * @param element
   */
  @method
  public hasAriaLabel(element: JQLite) {
    let node = this.$mdUtil.getNativeElement(element);

    /* Check if compatible node type (ie: not HTML Document node) */
    if (!node.hasAttribute) {
      return false;
    }

    /* Check label or description attributes */
    return node.hasAttribute('aria-label') || node.hasAttribute('aria-labelledby') || node.hasAttribute('aria-describedby');
  }
  private performCheck(parentNode: HTMLElement) {
    // console.log(this);
    if (this.hasAriaLabel(parentNode as any)) {
      return false;
    }
    /* Perform role blacklist check */
    if (parentNode.hasAttribute('role')) {
      switch (parentNode.getAttribute('role').toLowerCase()) {
        case 'command':
        case 'definition':
        case 'directory':
        case 'grid':
        case 'list':
        case 'listitem':
        case 'log':
        case 'marquee':
        case 'menu':
        case 'menubar':
        case 'note':
        case 'presentation':
        case 'separator':
        case 'scrollbar':
        case 'status':
        case 'tablist':
          return false;
      }
    }
    /* Perform tagName blacklist check */
    switch (parentNode.tagName.toLowerCase()) {
      case 'abbr':
      case 'acronym':
      case 'address':
      case 'applet':
      case 'audio':
      case 'b':
      case 'bdi':
      case 'bdo':
      case 'big':
      case 'blockquote':
      case 'br':
      case 'canvas':
      case 'caption':
      case 'center':
      case 'cite':
      case 'code':
      case 'col':
      case 'data':
      case 'dd':
      case 'del':
      case 'dfn':
      case 'dir':
      case 'div':
      case 'dl':
      case 'em':
      case 'embed':
      case 'fieldset':
      case 'figcaption':
      case 'font':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
      case 'hgroup':
      case 'html':
      case 'i':
      case 'ins':
      case 'isindex':
      case 'kbd':
      case 'keygen':
      case 'label':
      case 'legend':
      case 'li':
      case 'map':
      case 'mark':
      case 'menu':
      case 'object':
      case 'ol':
      case 'output':
      case 'pre':
      case 'presentation':
      case 'q':
      case 'rt':
      case 'ruby':
      case 'samp':
      case 'small':
      case 'source':
      case 'span':
      case 'status':
      case 'strike':
      case 'strong':
      case 'sub':
      case 'sup':
      case 'svg':
      case 'tbody':
      case 'td':
      case 'th':
      case 'thead':
      case 'time':
      case 'tr':
      case 'track':
      case 'tt':
      case 'ul':
      case 'var':
        return false;
    }
    return true;
  }
  /**
   * Check if expected element's parent has aria label attribute and has valid role and tagName
   * @param element
   * @param {optional} level Number of levels deep search should be performed
   */
  @method
  public parentHasAriaLabel(element: JQLite | HTMLElement, level: any = 1): boolean {
    let node = this.$mdUtil.getNativeElement(element as any);
    if (!node.parentNode) {
      return false;
    }
    if (this.performCheck(node.parentNode as any)) {
      return true;
    }
    level--;
    if (level) {
      return this.parentHasAriaLabel(node.parentNode as any, level);
    }
    return false;
  }
}
